<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jack.minardi.org</title><link>http://jack.minardi.org/</link><description></description><atom:link href="http://jack.minardi.org/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 22 Jul 2013 00:00:00 -0000</lastBuildDate><item><title>What's in a Shadow?</title><link>http://jack.minardi.org/software/whats-in-a-shadow</link><description>&lt;p&gt;&lt;a href='https://commons.wikimedia.org/wiki/File:Backlit_sphere_with_shadow.jpg' id='borderless'&gt;
&lt;img alt="shadow header" src="http://jack.minardi.org/static/images/shadow-header.png" /&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you'd rather read python than english you can go straight to the code on github:
https://github.com/jminardi/volume-from-shadow&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;I was having fun casting shadows with my laser pointer the other day. I began
to wonder about the 3D information that was embedded in the 2D shadow. Given
enough shadows of an object, could you recreate it? What information is lost,
what is preserved?&lt;/p&gt;
&lt;p&gt;I needed to apply a few constraints to simplify the system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let the light rays be parallel to each other&lt;/li&gt;
&lt;li&gt;Let the light fall perpendicular to the shadowed surface.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Parallel light rays can be thought of as coming from an infinitely far source.
Having the rays come in orthogonal to the surface allows me to ignore any
perspective distortions like the &lt;a href="http://en.wikipedia.org/wiki/Keystone_effect"&gt;keystone
effect&lt;/a&gt;. I've drawn up a simple
diagram to explain what I am talking about.&lt;/p&gt;
&lt;p&gt;&lt;img alt="shadow diagram" src="http://jack.minardi.org/static/images/shadow-diagram.png" /&gt;&lt;/p&gt;
&lt;p&gt;Now imaging rotating that object and watching the shadow change on the wall.&lt;/p&gt;
&lt;p&gt;These musings led to some python code that implements a sort of shadow
back projection - recreating a 3D object from a series of shadows taken at
different rotations. The general algorithm goes something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;points&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;generate_random_cloud&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;each&lt;/span&gt; &lt;span class="n"&gt;shadow:&lt;/span&gt;
    &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove_impossible_points_for_shadow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shadow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The basic idea is to iterate over all shadows removing the points that would
fall outside the shadow. The points that remain after all iterations fall
inside the 3D volume consistent with all the given shadows. In my
implementation I assumed shadows taken at equal intervals of rotation about the
z-axis, but you could easily specify the object's angle of rotation for each
shadow.&lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;matplotlib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;mlab&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;whittle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cloud&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;polygons&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Parameters&lt;/span&gt;
&lt;span class="sd"&gt;    ----------&lt;/span&gt;
&lt;span class="sd"&gt;    cloud : ndarray&lt;/span&gt;
&lt;span class="sd"&gt;        Mx3 array containing the point cloud. Columns are x, y, and z&lt;/span&gt;
&lt;span class="sd"&gt;        Should be centered about the origin&lt;/span&gt;
&lt;span class="sd"&gt;    polygons : list of ndarray&lt;/span&gt;
&lt;span class="sd"&gt;        Each array is Mx2 and represents a series of x, y points defining a&lt;/span&gt;
&lt;span class="sd"&gt;        polygon.&lt;/span&gt;

&lt;span class="sd"&gt;    Returns&lt;/span&gt;
&lt;span class="sd"&gt;    -------&lt;/span&gt;
&lt;span class="sd"&gt;    cloud : ndarray&lt;/span&gt;
&lt;span class="sd"&gt;        Mx3 array representing the points from the original cloud that are&lt;/span&gt;
&lt;span class="sd"&gt;        contained inside the 3d volume defined by the series of polygons&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="c"&gt;# Divide half the circle evenly among the polygons&lt;/span&gt;
    &lt;span class="n"&gt;angle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;polygons&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;rotation_matrix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_rotation_matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;angle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;polygon&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;polygons&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c"&gt;# Find and remove the points that fall outside the current projection&lt;/span&gt;
        &lt;span class="n"&gt;mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mlab&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inside_poly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cloud&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:],&lt;/span&gt; &lt;span class="n"&gt;polygon&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cloud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cloud&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="c"&gt;# Rotate the cloud and go to the next projection&lt;/span&gt;
        &lt;span class="n"&gt;cloud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cloud&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rotation_matrix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cloud&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_rotation_matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;angle&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# Rotate about the z-axis&lt;/span&gt;
    &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;angle&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;angle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;rotation_matrix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([[&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                                &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                                &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rotation_matrix&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see there is really not that much going on here. This code simply
masks out the points that fall outside the shadow using &lt;code&gt;inside_poly()&lt;/code&gt;,
rotates the cloud, then masks again. You may notice you don't need the whole
circle, two profiles taken 180 degrees apart should be mirror images of each
other - giving no new information.&lt;/p&gt;
&lt;p&gt;For example, I could define two diamonds and run them through the &lt;code&gt;wittle&lt;/code&gt;
function. The result should be two pyramids touching at their bases. One
diamond is defines by its vertices below.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;polygon&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Results&lt;/h2&gt;
&lt;p&gt;Two of the diamonds above produce the following 3D volume:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/pyramid.gif' id='borderless' width=500&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Stereoscopic image, cross your eyes to view.
(&lt;a href="http://www.neilcreek.com/2008/02/28/how-to-see-3d-photos/"&gt;tutorial&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So it works for simple shadows and objects! I wanted to try something a little
more difficult, so I decided to test the algorithms on my (dead) bonsai tree.&lt;/p&gt;
&lt;p&gt;&lt;a href='/static/images/bonsai.jpg', id='borderless'&gt;
&lt;img src='/static/images/bonsai.jpg' id='borderless' width=400&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I took four photographs at (hopefully) 45 degree increments. I then
wrote a quick &lt;a href="https://github.com/jminardi/volume-from-shadow/blob/master/selection_plot.py"&gt;tool&lt;/a&gt;
that allows me to click on an image to define a polygon. I used it to define
the profile of each of the four images. You can see the images and profiles
below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tree photos" src="http://jack.minardi.org/static/images/tree-photos.png" /&gt;&lt;/p&gt;
&lt;p&gt;Running the 4 polygons above through the function produced the following point
cloud:&lt;/p&gt;
&lt;p&gt;&lt;a href='/static/images/bonsai-large.gif', id='borderless'&gt;
&lt;img src='/static/images/bonsai-small.gif' id='borderless' width=600&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Click for high res GIF. Stereoscopic image, cross your eyes to view.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I could imaging automating the polygon extraction with some image processing.
Using a lazy susan and a cheap web cam you could easily import your objects into
a video game like Minecraft.&lt;/p&gt;
&lt;p&gt;I was pleasantly surprised with these results, however there are a few
limitations.  This method can never recreate concave shapes such as a bowl. Any
concavity will simply be filled in, as that information is lost in the 3d -&amp;gt;
2d projection.&lt;/p&gt;
&lt;p&gt;While this algorithm's output is great for human consumption, a point cloud is
not the optimal data store for a 3d volume. I played around a bit with being a
little more clever than random when creating the cloud, which you can see
&lt;a href="https://github.com/jminardi/volume-from-shadow/blob/master/3d_projection.py#L57"&gt;here&lt;/a&gt;
, but I think this is barking up the wrong tree. I have a few ideas involving
more complex polygon intersection algorithms that would result in a mesh grid
rather than a point cloud. Maybe someday I'll try to get those spelled out in
python.&lt;/p&gt;
&lt;p&gt;Questions? Hit me up on &lt;a href="http://www.twitter.com/jackminardi"&gt;twitter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can find all the code on github:
https://github.com/jminardi/volume-from-shadow&lt;/p&gt;
&lt;p&gt;Check out the discussion on &lt;a href="https://news.ycombinator.com/item?id=6122911"&gt;Hacker News&lt;/a&gt;
where you can find links to similar research.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jack Minardi</dc:creator><pubDate>Mon, 22 Jul 2013 00:00:00 -0000</pubDate><guid>tag:jack.minardi.org,2013-07-22:software/whats-in-a-shadow</guid></item><item><title>Replace Dropbox with BitTorrent Sync and a Raspberry Pi</title><link>http://jack.minardi.org/raspberry_pi/replace-dropbox-with-bittorrent-sync-and-a-raspberry-pi</link><description>&lt;h2&gt;Notes Everywhere&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Messy Desk" src="http://jack.minardi.org/static/images/messy-desk.png" /&gt;
&lt;a href="http://www.flickr.com/photos/jazzmasterson/278672002/"&gt;source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I like to take long running notes, jotting down an idea here and there when
one pops up. I never know which devices I will have with me, so I like to have
these notes synced across all of them.&lt;/p&gt;
&lt;p&gt;Previously I had been using the Chrome plugin
&lt;a href="https://chrome.google.com/webstore/detail/quick-note/mijlebbfndhelmdpmllgcfadlkankhok?hl=en-US"&gt;QuickNote&lt;/a&gt;
which is a light weight interface on top of the &lt;a href="http://www.diigo.com"&gt;diigo&lt;/a&gt;
cloud service. I had been using it for about two years and never had a problem
until a few days ago. I somehow managed to lose about three months of edits. I
still have not quite shaken that feeling of despair knowing I will never get my
data back, but it did finally force me to beef up my note-syncing system.
While I will primarily be using this setup to sync notes, it is by no means
limited to only text files.&lt;/p&gt;
&lt;h2&gt;Enter BitTorrent Sync&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://labs.bittorrent.com/experiments/sync.html"&gt;BitTorrent Sync&lt;/a&gt; is a free
utility that uses the bittorrent protocol to keep folders in sync across
devices. It can be used with OS X, Windows, Android and Linux. It is not
however open source, which might be a deal breaker for some.  But if this 
isn't too big a pill for you to swallow, with a little bit of work you can use
btsync as a free syncing solution.&lt;/p&gt;
&lt;p&gt;While Dropbox requires you to keep a copy of your data on their servers, 
btsync never requires your data to inhabit a device you do not own.
This is nice for security, but it means to sync between two devices they both
need to be online at the same time. That is where the Raspberry Pi comes in.
You can use the Pi as a node in your sync network, so a change to a file on any
device will sync with the Pi and then other devices will get the change when
they come online.&lt;/p&gt;
&lt;p&gt;First we will set up the Pi as the central server and then we will connect our
devices to it. (It is important to note however that the Pi is not a special
"server" node, it is just a regular node like any other device.)&lt;/p&gt;
&lt;h2&gt;Installing BitTorrent Sync on the Raspberry Pi&lt;/h2&gt;
&lt;p&gt;NOTE: I am using Raspbian Wheezy, but I suspect these ideas will translate to
other operating systems.&lt;/p&gt;
&lt;p&gt;You need to grab the &lt;a href="http://btsync.s3-website-us-east-1.amazonaws.com/btsync_arm.tar.gz"&gt;ARM
build&lt;/a&gt; of
BitTorrent Sync:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir ~/.btsync &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ~/.btsync
wget http://btsync.s3-website-us-east-1.amazonaws.com/btsync_arm.tar.gz
tar -xvf btsync_arm.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Unless you have a large SD in your Pi you will probably want to use an external
drive for your sync location. I will be using a USB thumb drive. You may need
to format your thumb drive as EXT4 if you are having issues. (&lt;em&gt;WARNING! This
will erase all data on your drive&lt;/em&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;df -h                               &lt;span class="c"&gt;# find your drive here, e.g. `sda1`&lt;/span&gt;
sudo umount /dev/sda1               &lt;span class="c"&gt;# replace sda1 with your drive name !&lt;/span&gt;
sudo mkfs.ext4 /dev/sda1 -L BTSync  &lt;span class="c"&gt;# replace sda1 with your drive name !&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now all you have to do is launch the btsync application and you will be up and
running!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.btsync
sudo ./btsync  &lt;span class="c"&gt;# can be killed with `sudo killall btsync`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you see the following output btsync is properly running.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;BitTorrent Sync forked to background. &lt;span class="nv"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 3003
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Navigate your browser to &lt;code&gt;Your-Pi-IP-Address:8888/gui&lt;/code&gt; to manage the btsync
process. To add the thumb drive select "Add Folder" and navigate to
&lt;code&gt;/media/BTSync&lt;/code&gt;. You will need to generate a secret as this is the first time
you are adding the folder.&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/btsync-web-interface.png' id='borderless'&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Add Folfer" src="http://jack.minardi.org/static/images/add-folder.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Other Devices&lt;/h2&gt;
&lt;p&gt;Now go download the
&lt;a href="https://play.google.com/store/apps/details?id=com.bittorrent.sync"&gt;Android app&lt;/a&gt;
and/or the &lt;a href="http://labs.bittorrent.com/experiments/sync.html"&gt;desktop app&lt;/a&gt; and
connect them using the secret you just generated It's that simple! Any change
on any device will be synced across all online devices. If you keep your Pi
online it will store and push the most up to date content as your other devices
go on and off line.&lt;/p&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;h3&gt;Start at Boot&lt;/h3&gt;
&lt;p&gt;You may want to set btsync to start when you boot your Raspberry Pi. To do that
we will place a script in &lt;code&gt;/etc/init.d/&lt;/code&gt; and then register it with
&lt;code&gt;update-rc.d&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo nano /etc/init.d/btsync
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Paste the following code in the script&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#! /bin/sh&lt;/span&gt;
&lt;span class="c"&gt;# /etc/init.d/btsync&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;

&lt;span class="c"&gt;# Carry out specific functions when asked to by the system&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;$1&amp;quot;&lt;/span&gt; in
start&lt;span class="o"&gt;)&lt;/span&gt;
    /home/pi/.btsync/btsync
    ;;
stop&lt;span class="o"&gt;)&lt;/span&gt;
    killall btsync
    ;;
*&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Usage: /etc/init.d/btsync {start|stop}&amp;quot;&lt;/span&gt;
    &lt;span class="nb"&gt;exit &lt;/span&gt;1
    ;;
&lt;span class="k"&gt;esac&lt;/span&gt;

&lt;span class="nb"&gt;exit &lt;/span&gt;0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then change the permissions, test, and register it to run at boot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo chmod 755 /etc/init.d/btsync
sudo /etc/init.d/btsync start       &lt;span class="c"&gt;# test that the script starts&lt;/span&gt;
sudo /etc/init.d/btsync stop        &lt;span class="c"&gt;# test that the script stops&lt;/span&gt;
sudo update-rc.d btsync defaults
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Password Protect Web Interface&lt;/h3&gt;
&lt;p&gt;If you expose your web interface to the outside world (or if you don't trust
your friends) you are going to want to password protect it.  This can be done
with a btsync config file passed to the executable at runtime with the
&lt;code&gt;--config&lt;/code&gt; flag. First, use btsync to generate a sample config file, modify it
to fit your needs, and restart the process.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.btsync
./btsync --dump-sample-config &amp;gt; btsync.conf
&lt;span class="c"&gt;# browse the sample config file and change what you want&lt;/span&gt;
sudo killall btsync
sudo ./btsync --config btsync.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HINT: Use &lt;a href="http://jsonlint.com/"&gt;jsonlint&lt;/a&gt; to validate your config file if
btsync complains. Also make sure to modify the &lt;code&gt;/etc/init.d/btsync&lt;/code&gt; script to
use the config file as well.&lt;/p&gt;
&lt;p&gt;Questions? Hit me up on twitter
&lt;a href="http://www.twitter.com/jackminardi"&gt;@jackminardi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can also follow the
&lt;a href="https://news.ycombinator.com/item?id=6071604"&gt;discussion on HN&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jack Minardi</dc:creator><pubDate>Sat, 20 Jul 2013 00:00:00 -0000</pubDate><guid>tag:jack.minardi.org,2013-07-20:raspberry_pi/replace-dropbox-with-bittorrent-sync-and-a-raspberry-pi</guid></item><item><title>open('/dev/real_world')</title><link>http://jack.minardi.org/raspberry_pi/opendevreal_world</link><description>&lt;p&gt;I gave a talk at SciPy 2013 titled &lt;strong&gt;&lt;code&gt;open('dev/real_world')&lt;/code&gt; Raspberry Pi
Sensor and Actuator Control.&lt;/strong&gt; You can find the video on
&lt;a href="http://www.youtube.com/watch?v=TCGLzNf9yHI"&gt;youtube&lt;/a&gt;, the slides on &lt;a href="https://docs.google.com/a/minardi.org/presentation/d/19ErI3QJfSZ8uIBDV2MK0VvFkfcgkvK-Tm0Sz84AxvNI/edit#slide=id.gc8567ed3_046"&gt;google
drive&lt;/a&gt;
and I will summarize the content here.&lt;/p&gt;
&lt;p&gt;Typically as a programmer you will work with data on disk, and if you are
lucky you will draw pictures on the screen. This is in contrast to physical
computing which allows you as a programmer to work with data sensed in from
the real world and to control devices that move in the real world.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Mars Rover" src="http://jack.minardi.org/static/images/mars-rover.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;physical computing at work. (&lt;a href="http://www.flickr.com/photos/alpi-costerni/8148100978/sizes/m/in/photostream/"&gt;source&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Goal&lt;/h1&gt;
&lt;p&gt;Use a Raspberry Pi to read in accelerometer value and to control a servo motor.&lt;/p&gt;
&lt;h1&gt;Definitions&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Raspberry Pi&lt;ul&gt;
&lt;li&gt;Small $35 Linux computer with 2 USB ports, HDMI out, Ethernet, and most
importantly...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GPIO Pins&lt;ul&gt;
&lt;li&gt;General Purpose Input/Output Pins&lt;/li&gt;
&lt;li&gt;This is the component that truly enables "physical computing". You as a
programmer can set the voltage high or low on each pin, which is how you
will talk to actuators. You can also read what the voltage is currently on
each pin.  This is how sensors will talk back to you. It is important to
note that each pin represents a binary state, you can only output a 0 or a
1, nothing in between.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this article I will go over four basic Python projects to demonstrate the
hardware capabilities of the Raspberry Pi. Those projects are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blink an LED.&lt;/li&gt;
&lt;li&gt;Read a pot.&lt;/li&gt;
&lt;li&gt;Stream data.&lt;/li&gt;
&lt;li&gt;Control a servo.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;Blink an LED.&lt;/h1&gt;
&lt;p&gt;An LED is a Light Emitting Diode. A diode is a circuit element that allows
current to flow in one direction but not the other. Light emitting means ...
it emits light. Your typical LED needs current in the range of 10-30 mA and
will drop about 2-3 volts. If you connect an LED directly to your Pi's GPIO it
will source much more than 30 mA and will probably fry your LED (and possibly
your Pi). To prevent this we have to put a resistor. If you want to do math you
can calculate the appropriate resistance using the following equation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Vs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Vd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But if you don't want to do math then pick a resistor between 500-1500 ohms.
Once you've gathered up all your circuit elements (LED and resistor), build
this circuit on a &lt;a href="http://eecs.vanderbilt.edu/courses/ee213/Breadboard.htm"&gt;bread
board&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="LED Circuit" src="http://jack.minardi.org/static/images/led-circuit.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;thats not so bad, is it?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The code is also pretty simple. But first you will need to install
&lt;a href="code.google.com/p/raspberry-gpio-python/"&gt;RPi.GPIO&lt;/a&gt;. (It might come
preinstalled on your OS.)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;RPi.GPIO&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;io&lt;/span&gt;

&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setmode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BCM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The important lines basically are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These lines of code setup pin &lt;a href="http://www.abluestar.com/blog/wp-content/uploads/2013/02/Raspberry-Pi-GPIO-Layout-Revision-1-e1347664808358.png"&gt;12&lt;/a&gt;
as an output, and then output a 1 (3.3 volts). Run the above code connected to
the circuit and you should see your LED blinking on and off every half second.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Read a pot.&lt;/h1&gt;
&lt;p&gt;A pot is short for potentiometer, which is a variable resistor. This is just
a fancy word for knob. Basically by turning the knob you affect the resistance,
which affects the voltage across the pot. (&lt;code&gt;V = IR&lt;/code&gt;, remember?). Changing
voltage relative to some physical value is how many sensors work, and this
class of sensor is known as an &lt;em&gt;analog sensor&lt;/em&gt;. Remember when I said the GPIO
pins can only represent a binary state? We will have to call in the aide of
some more silicon to convert that analog voltage value into a binary stream of
bits our Pi can handle.&lt;/p&gt;
&lt;p&gt;That chunk of silicon is refered to as an Analog-to-Digital Converter (ADC).
The one I like is called &lt;a href="http://adafru.it/856"&gt;MCP3008&lt;/a&gt;, it has 8 10-bit
channels, meaning we can read 8 sensors values with a resolution of 1024 each 
(2^10). This will map our input voltage of 0 - 3.3 volts to an integer between
0 and 1023.&lt;/p&gt;
&lt;p&gt;&lt;img alt="LED Circuit" src="http://jack.minardi.org/static/images/pot-circuit.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;I've turned the Pi into ephemeral yellow labels to simplify the diagram&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To talk to the chip we will need a python package called
&lt;a href="https://github.com/doceme/py-spidev"&gt;spidev&lt;/a&gt;. For more information about the
package and how it works with the MCP3008 check out this great &lt;a href="http://jeremyblythe.blogspot.co.uk/2012/09/raspberry-pi-hardware-spi-analog-inputs.html"&gt;blog
post&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;With spidev installed and the circuit built run the following program to read
live sensor values and print them to stdout.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;spidev&lt;/span&gt;       
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;

&lt;span class="n"&gt;spi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;spidev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SpiDev&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;spi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;readadc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adcnum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;adcnum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;spi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xfer2&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;adcnum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;adcout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;adcout&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;readadc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The most important parts are these two lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;spi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xfer2&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;adcnum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;adcout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;They send the read command and extract the relevant returned bits. See the
blog post I linked above for more information on what is going on here.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Stream data.&lt;/h1&gt;
&lt;p&gt;To stream data over the wire we will be using the &lt;a href="http://www.zeromq.org/"&gt;ØMQ networking
library&lt;/a&gt; and implementing the REQUEST/REPLY pattern.
ØMQ makes it super simple to set up a client and server in Python. The
following is a complete working example.&lt;/p&gt;
&lt;h2&gt;Server&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;zmq&lt;/span&gt;

&lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;REP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;tcp://*:1980&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;#39;m here&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Client&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;zmq&lt;/span&gt;

&lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;tcp://192.168.1.6:1980&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;You home?&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we can use &lt;a href="https://github.com/enthought/traits"&gt;traits&lt;/a&gt; and
&lt;a href="https://github.com/enthought/enaml"&gt;enaml&lt;/a&gt; to make a pretty UI on the client
side. Check out the &lt;a href="https://github.com/jminardi/scipy2013/tree/master/acc_plot"&gt;acc_plot
demo&lt;/a&gt; in the github
repo to see an example of the Pi streaming data over the wire to be plotted by
a client.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Control a servo&lt;/h1&gt;
&lt;p&gt;Servos are (often small) motors which you can drive to certain positions. For
example, for a given servo you may be able to set the drive shaft from 0 to 18o
degrees, or anywhere in between. As you can imagine, this could be useful for
a lot of tasks, not least of which is robotics.&lt;/p&gt;
&lt;p&gt;Shaft rotation is controlled by &lt;a href="https://en.wikipedia.org/wiki/Pulse-width_modulation"&gt;Pulse Width Modulation
(PWM)&lt;/a&gt; in which you
encode information in the duration of a high voltage pulse on the GPIO pins.
Most hobby servos follow a standard pulse width meaning. A 0.5 ms pulse means
go to your min position and a 2.5 ms pulse means go to your max position. Now
repeat this pulse every 20 ms and you're controlling a servo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="PWM Diagram" src="http://jack.minardi.org/static/images/pwm.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The pulse width is much more critical than the frequency&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;These kind of timings are not possible with Python. In fact, they aren't really
possible with a modern operating system. An interrupt could come in at any time
in your control code, causing a longer than desired pulse and a jitter in your
servo. To meet the timing requirements we have to enter the fun world of
kernel modules. &lt;a href="https://github.com/richardghirst/PiBits"&gt;ServoBlaster&lt;/a&gt; is a 
kernel module that makes use of the DMA control blocks to bypass the CPU
entirely. When loaded, the kernel module opens a device file at
&lt;code&gt;/dev/servoblaster&lt;/code&gt; that you can write position commands to.&lt;/p&gt;
&lt;p&gt;I've written a small object oriented layer around this that makes servo control
simpler. You can find my library here:&lt;/p&gt;
&lt;p&gt;https://github.com/jminardi/RobotBrain&lt;/p&gt;
&lt;p&gt;Simple connect the servo to 5v and ground on your Pi and then connect the
control wire to pin 4.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Servo Diagram" src="http://jack.minardi.org/static/images/servo.png" /&gt;&lt;/p&gt;
&lt;p&gt;The python code is quite simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;robot_brain.servo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Servo&lt;/span&gt;

&lt;span class="n"&gt;servo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Servo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.05&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;servo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All you have to do is instantiate a servo and call its &lt;code&gt;set()&lt;/code&gt; method with a
floating point value between 0 and 1. Check out the &lt;a href="https://github.com/jminardi/scipy2013/tree/master/servo_slider"&gt;servo_slider
demo&lt;/a&gt; on
github to see servo control implemented over the network.&lt;/p&gt;
&lt;hr /&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jack Minardi</dc:creator><pubDate>Mon, 08 Jul 2013 00:00:00 -0000</pubDate><guid>tag:jack.minardi.org,2013-07-08:raspberry_pi/opendevreal_world</guid></item><item><title>YCombinator Hardware Hackathon</title><link>http://jack.minardi.org/raspberry_pi/ycombinator-hardware-hackathon</link><description>&lt;p&gt;I recently participated in the &lt;a href="http://upverter.com/hackathons/yc-hackathon-2013/"&gt;Upverter + YCombinator Hardware
Hackathon&lt;/a&gt;, where my team
placed first overall.&lt;/p&gt;
&lt;p&gt;You can find my TechCrunch interview about the event here:
&lt;a href="http://techcrunch.com/2013/02/26/y-combinator-hardware-hackathon-winner/"&gt;http://techcrunch.com/2013/02/26/y-combinator-hardware-hackathon-winner/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I went it with only an idea, and spent the first half hour trying to convince
other people to spend their day hacking with me.&lt;/p&gt;
&lt;p&gt;The hackathon lasted about 10 hours, and the goal was to design and build a
prototype hardware device. For our entry, my team built a wearable force
feedback glove. When worn, the glove is able to simulate the feeling of holding
a physical object.&lt;/p&gt;
&lt;p&gt;Here is a picture of the completed glove:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/hackathon/glove.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;A device like this could be used for gaming, surgical assistance, or a number
of other augmented reality applications. I have been interested in expanding
the human-computer interface for a while, and this project allowed me to open
up another channel for computers to feed back information to humans.&lt;/p&gt;
&lt;h2&gt;Mechanical Design&lt;/h2&gt;
&lt;p&gt;A length of twine is connected from the glove's fingertips, through two guiding
braces, and back to a hobby servo. This is repeated for each finger. The servo
is connected to a platform which is connected to the back of the glove. When
the servo is actuated it pulls back on the twine holding the fingers open.
Through this process we are able to simulate the resistive force of an object
holding the wearers hand open.&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/hackathon/diagram.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;-Drawing by teammember Tom Sherlock&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For the demo at the competition, we used a distance sensor to set the hand
position. The closer your hand was to the distance sensor, the more your
fingers were pulled open. This simulated the feeling of squeezing a virtual
object in your hand.&lt;/p&gt;
&lt;p&gt;The distance sensor used was a HC-SR04 Ping Sensor:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/hackathon/hc-sr04.jpg' width=600&gt;&lt;/p&gt;
&lt;h2&gt;Hardware I/O&lt;/h2&gt;
&lt;p&gt;To control servos and read from sensors usually you use GPIO pins. In our case
we used the GPIO pins on a Raspberry Pi. If you would like to know more about
hardware control with a Raspberry Pi check out my
&lt;a href="http://jack.minardi.org/raspberry_pi/opendevreal_world/"&gt;article&lt;/a&gt; on that
topic.&lt;/p&gt;
&lt;p&gt;The basic idea is that you can set the voltage on a GPIO pin high (5 volts) or
low (0 volts). Sending the correct sequence of high and low pulses to a servo
will cause it to go to a certain position. You can also read whether a certain
pin is high or low. If you connect a sensor to GPIO pin, it is able to
communicate information by sending specific sequences of high and low pulses.&lt;/p&gt;
&lt;h2&gt;Control Software&lt;/h2&gt;
&lt;p&gt;To control the GPIO pins I wrote a Python script that you can find here:
&lt;a href="https://gist.github.com/jminardi/5022297"&gt;https://gist.github.com/jminardi/5022297&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This script uses a library I wrote called
&lt;a href="https://github.com/jminardi/RobotBrain"&gt;RobotBrain&lt;/a&gt;. It sits on top of
&lt;a href="https://pypi.python.org/pypi/RPi.GPIO"&gt;RPi.GPIO&lt;/a&gt; and provides a higher level
interface for controlling individual pins and motors. The only module used in
this project was the Servo, which makes it easy to set a servo to a given
position. The Servo module uses the
&lt;a href="https://github.com/richardghirst/PiBits/tree/master/ServoBlaster"&gt;ServoBlaster&lt;/a&gt;
kernal module under the covers, which exposes the servo as device in the
filesystem.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In the end I had a great time at the hackathon. I think we were able to put
together a winning demo in part because of the power of Python. With just a few
libraries you are able to reason at a high level about what you wanted your hardware
to do and what your sensors are seeing. If you have ever tried doing hardware
control in a lower level language, you know just how hard that can be, and as
you can see, how easy Python makes it.&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/hackathon/team.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The team after our victory&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jack Minardi</dc:creator><pubDate>Tue, 05 Mar 2013 00:00:00 -0000</pubDate><guid>tag:jack.minardi.org,2013-03-05:raspberry_pi/ycombinator-hardware-hackathon</guid></item><item><title>Android Controlled Toy Car</title><link>http://jack.minardi.org/raspberry_pi/android-controlled-toy-car</link><description>&lt;p&gt;I wanted to build something fun that would introduce me to hardware control 
with the Raspberry Pi. I decided to build a small car that could be
controlled with my phone's accelerometer.&lt;/p&gt;
&lt;p&gt;Here is a picture of the fully assembled car:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/toycar/assembled.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;I wrote an &lt;a href="https://github.com/jminardi/RobotBrain-Controller"&gt;android app&lt;/a&gt;
that streams the accelerometer data from the phone to the pi over a simple
socket.  The pi then uses this data to drive the DC motor and the servo motor.
Tilting the phone to control the car feels very natural.&lt;/p&gt;
&lt;p&gt;In this pic you can see the wifi dongle I've used:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/toycar/raspberrypi.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;I am using Adafruit &lt;a href="http://learn.adafruit.com/adafruit-raspberry-pi-educational-linux-distro/occidentalis-v0-dot-2"&gt;Occidental
v0.2&lt;/a&gt;
as my OS because it has support for my wifi dongle. It also makes some hardware
interaction easier and comes pre-installed with a few good python libraries.&lt;/p&gt;
&lt;p&gt;Here is a picture of the breadboard:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/toycar/breadboard.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;I am using the
&lt;a href="http://www.mouser.com/ProductDetail/Texas-Instruments/L293DNE/?qs=sGAEpiMZZMtYFXwiBRPs0wSafWlCmJbc"&gt;L293DNE&lt;/a&gt;
hbridge chip for DC motor control. The two black wires you see coming off the
board connect to the motor.&lt;/p&gt;
&lt;p&gt;In this pic is the battery pack I am using to power the pi:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/toycar/charger.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;I purchased it on amazon
&lt;a href="http://www.amazon.com/PowerGen-External-Blackberry-Sensation-Thunderbolt/dp/B005VBNYDS"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is a pic of the battery pack I am using for the DC motor:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/toycar/batterypack.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;Here is a closeup of the steering servo:&lt;/p&gt;
&lt;p&gt;&lt;img src='/static/images/toycar/servo.jpg' width=600&gt;&lt;/p&gt;
&lt;p&gt;It is an &lt;a href="http://www.servocity.com/html/hs-55_sub-micro.html"&gt;HS-55&lt;/a&gt; and I
power it directly from the pi's 5v rail. To control it I use the &lt;a href="https://github.com/richardghirst/PiBits"&gt;servoblaster
kernal module&lt;/a&gt; and my own servo
control library &lt;a href="https://github.com/jminardi/RobotBrain"&gt;RobotBrain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;My next plans are to add some sensors and make it autonomous.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jack Minardi</dc:creator><pubDate>Sun, 09 Dec 2012 00:00:00 -0000</pubDate><guid>tag:jack.minardi.org,2012-12-09:raspberry_pi/android-controlled-toy-car</guid></item></channel></rss>